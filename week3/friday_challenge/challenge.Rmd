---
title: "RNA-seq tutorial - Data QC"
author: "UZH n UU:"
date: "`r format(Sys.time(), '%d %B, %Y')`"
---

# Challenge - Count QC

RNAseq can be analysed in two ways. The first method involves mapping the reads 
to the reference genome with a splice-aware aligner (e.g.STAR) and the n
quantifying the expression of genes from the alignments e.g with featureCounts 
R package. The second method involves quantifying gene expression via 
psedualignment e.g. with Kallisto. The second method takes a lot less time due 
to omitting read alignment to the genome and directly generating counts.

Here we generated for you two tables quantifying the expression of genes per a 
set of samples using both methods.

The data is from yeast RNA sequencing. The tables are stored as rds objects 
which take less space. 

Hint: to read in the tables use `readRDS` function.

```{r}
suppressPackageStartupMessages({
  library(SummarizedExperiment)
  library(pheatmap)
  library(RColorBrewer)
  library(stringr)
  library(plotly)
  library(tidyverse)
  library(dplyr)
})
```

## Exercise #1

1.  Load in the tables and take a look at the first 10 rows.

```{r}
# Write your code here
```

<!-- -->

2.  Take a moment to look at the outputs of Kallisto and featureCounts. 
Are the rows the same? How can you check? What about the columns?

```{r}
# Write your code here
```

<!-- -->

3.  In what format are the counts outputted by kallisto? By featureCounts?
What influence could this possibly have on downstream analysis?

Hint: Think about on what "level" Kallisto quantifies RNA, versus the default
mode of featureCounts. 

Answer:

```{text}
[Your answer here. This question does not need you to writing any code!]
```


4.  Can you plot the total number of reads per sample?

```{r}
# Wdfrite your code here
```

## Excercise #2

Now that the we have generated the counts, we can start exploring the data. 
We could proceed with either the counts generated by Kallisto or featureCounts. 
Let's use the featureCounts for now.

So now we have a count matrix of with the following dimensions: 8 x 6'600. 
In other words, we have represented each sample by a vector of 6'600 features. 
In order adequately QC our samples, one important aspect is determining how 
similar or dissimilar one vector of genes from a specific sample is that of 
another.

To do this we would like to use PCA (*principal component analysis*) and 
MDS (*multidimensional scaling*).

Lets load the data and define some basic parameters. I provide you with a 
code that prepares the data for PCA/MDS - have a look at the code annotation. 

```{r}
#Load the data tables
fc <- readRDS("featureCounts/mergedCounts.rds")

# Define meta dataframe for later use
meta <- data.frame(
  Condition=as.factor(rep(c("Glucose", "GlycEth"), each=4)),
  row.names=c(paste0("G", 1:4), paste0("GE", 1:4))
)

# Define some general-use parameters for use later
countDirectoryToUse <- "featureCounts"
sigThresh <- 10
conditionColours <- scales::hue_pal()(length(unique(meta$Condition)))
names(conditionColours) <- unique(meta$Condition)
sampleColours <- conditionColours[meta$Condition]

isPresent <- fc > sigThresh
rawCountsFilt = fc[which(apply(isPresent, 1, any)), ]
rawCountsFilt = round(rawCountsFilt,0)

dds <- DESeq2::DESeqDataSetFromMatrix(countData=rawCountsFilt,
                                      colData=meta,
                                      design=~Condition)
vsd <- DESeq2::vst(dds)

# Extract normalized counts
vsdSE <- SummarizedExperiment::assay(vsd)
```

### PCA

PCA is a linear dimensionality reduction technique which, in essence, tries to 
find a rotation of the data in order to maximise the variance. This is a common 
method for dimensionality reduction across many different disciplines within 
Computer Science and beyond. We will use the built-in R-method `prcomp` below 
to calculate the principal components and manually calculate the variance 
explained by each component.

Additionally, we will plot a 'scree' plot, which aims to visualise the 
variance explained by each principal component.

Using the vsdSE object, carry out and plot the PCA and the scree plot.

```{r}
#Your code here
```

### Multi-dimensional scaling (MDS)

Multi-dimensional scaling is another dimensionality reduction which aims to 
best reconstruct pairwise distances between a set of points given a set of 
distances. Since in the case of RNA-seq we are given the data vectors directly 
rather than the distance matrices, methods must calculate the distance matrix 
first upon which the MDS algorithm is then performed. PCA is used in the 
process to produce a reduced dimensionality projection from the similarities.

Here, we use limma [@limma] to calculate the MDS and use plotly to visualise 
the pairwise distances in 3-dimensions. Use the same vsdSE object.

```{r}
#Your code here
```

## Excercise #3

Correlation Heatmap

Similarly, we can call `pheatmap` on the correlations to easily visualize the 
similarity between samples within and across conditions. Use the vsdSE object 
to create a heatmap. 

Hint: You need to convert the normalized data into the 
correlation matrix. Use the following function to do so:

`cor(vsdSE, use="complete.obs")`

Do samples cluster according to condition?

```{r}
#Your code here
```
